#
# Description: fix cross-site scripting attack via invalid character sequences
# Ubuntu: https://bugs.launchpad.net/ubuntu/+source/icu/+bug/341834
# Patch: http://bugs.icu-project.org/trac/search?q=%22ticket:6175:%22&noquickjump=1&changeset=on
# Patch: https://bugzilla.redhat.com/attachment.cgi?id=321139 (thanks Red Hat)
#
diff -Nur -x '*.orig' -x '*~' icu-3.4.1a/build-tree/icu/source/common/ucnv2022.c icu-3.4.1a.new/build-tree/icu/source/common/ucnv2022.c
--- icu/source/common/ucnv2022.c	2005-06-03 16:17:54.000000000 -0400
+++ icu/source/common/ucnv2022.c	2009-03-25 11:15:25.000000000 -0400
@@ -176,6 +176,7 @@
 #ifdef U_ENABLE_GENERIC_ISO_2022
     UBool isFirstBuffer;
 #endif
+    UBool isEmptySegment;
     Cnv2022Type currentType;
     ISO2022State toU2022State, fromU2022State;
     UConverterSharedData *myConverterArray[UCNV_2022_MAX_CONVERTERS];
@@ -578,6 +579,7 @@
     if(choice<=UCNV_RESET_TO_UNICODE) {
         uprv_memset(&myConverterData->toU2022State, 0, sizeof(ISO2022State));
         myConverterData->key = 0;
+        myConverterData->isEmptySegment = FALSE;
     }
     if(choice!=UCNV_RESET_TO_UNICODE) {
         uprv_memset(&myConverterData->fromU2022State, 0, sizeof(ISO2022State));
@@ -783,6 +785,7 @@
             if(chosenConverterName == NULL) {
                 /* SS2 or SS3 */
                 *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
+                _this->toUCallbackReason = UCNV_UNASSIGNED;
                 return;
             }
 
@@ -902,6 +905,8 @@
     }
     if(U_SUCCESS(*err)) {
         _this->toULength = 0;
+    } else if(*err==U_UNSUPPORTED_ESCAPE_SEQUENCE) {
+        _this->toUCallbackReason = UCNV_UNASSIGNED;
     }
 }
 
@@ -1691,6 +1696,7 @@
                     continue;
                 } else {
                     /* only JIS7 uses SI/SO, not ISO-2022-JP-x */
+                    myData->isEmptySegment = FALSE;	/* reset this, we have a different error */
                     break;
                 }
 
@@ -1702,21 +1708,39 @@
                     continue;
                 } else {
                     /* only JIS7 uses SI/SO, not ISO-2022-JP-x */
+                    myData->isEmptySegment = FALSE;	/* reset this, we have a different error */
                     break;
                 }
 
             case ESC_2022:
                 mySource--;
 escape:
-                changeState_2022(args->converter,&(mySource), 
-                    mySourceLimit, ISO_2022_JP,err);
+                {
+                    const char * mySourceBefore = mySource;
+                    int8_t toULengthBefore = args->converter->toULength;
+
+                    changeState_2022(args->converter,&(mySource),
+                        mySourceLimit, ISO_2022_JP,err);
+
+                    /* If in ISO-2022-JP only and we successully completed an escape sequence, but previous segment was empty, create an error */
+                    if(myData->version==0 && myData->key==0 && U_SUCCESS(*err) && myData->isEmptySegment) {
+                        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
+                        args->converter->toUCallbackReason = UCNV_IRREGULAR;
+                        args->converter->toULength = toULengthBefore + (mySource - mySourceBefore);
+                    }
+                }
 
                 /* invalid or illegal escape sequence */
                 if(U_FAILURE(*err)){
                     args->target = myTarget;
                     args->source = mySource;
+                    myData->isEmptySegment = FALSE;	/* Reset to avoid future spurious errors */
                     return;
                 }
+                /* If we successfully completed an escape sequence, we begin a new segment, empty so far */
+                if(myData->key==0) {
+                    myData->isEmptySegment = TRUE;
+                }
                 continue;
 
             /* ISO-2022-JP does not use single-byte (C1) SS2 and SS3 */
@@ -1733,6 +1757,7 @@
                 /* falls through */
             default:
                 /* convert one or two bytes */
+                myData->isEmptySegment = FALSE;
                 cs = (StateEnum)pToU2022State->cs[pToU2022State->g];
                 if( (uint8_t)(mySourceChar - 0xa1) <= (0xdf - 0xa1) && myData->version==4 &&
                     !IS_JP_DBCS(cs)
@@ -2226,15 +2251,27 @@
 
             if(mySourceChar==UCNV_SI){
                 myData->toU2022State.g = 0;
+                if (myData->isEmptySegment) {
+                    myData->isEmptySegment = FALSE;	/* we are handling it, reset to avoid future spurious errors */
+                    *err = U_ILLEGAL_ESCAPE_SEQUENCE;
+                    args->converter->toUCallbackReason = UCNV_IRREGULAR;
+                    args->converter->toUBytes[0] = mySourceChar;
+                    args->converter->toULength = 1;
+                    args->target = myTarget;
+                    args->source = mySource;
+                    return;
+                }
                 /*consume the source */
                 continue;
             }else if(mySourceChar==UCNV_SO){
                 myData->toU2022State.g = 1;
+                myData->isEmptySegment = TRUE;	/* Begin a new segment, empty so far */
                 /*consume the source */
                 continue;
             }else if(mySourceChar==ESC_2022){
                 mySource--;
 escape:
+                myData->isEmptySegment = FALSE;	/* Any invalid ESC sequences will be detected separately, so just reset this */
                 changeState_2022(args->converter,&(mySource), 
                                 mySourceLimit, ISO_2022_KR, err);
                 if(U_FAILURE(*err)){
@@ -2245,6 +2282,7 @@
                 continue;
             }   
 
+            myData->isEmptySegment = FALSE;	/* Any invalid char errors will be detected separately, so just reset this */
             if(myData->toU2022State.g == 1) {
                 if(mySource < mySourceLimit) {
                     char trailByte;
@@ -2745,27 +2783,52 @@
             switch(mySourceChar){
             case UCNV_SI:
                 pToU2022State->g=0;
+                if (myData->isEmptySegment) {
+                    myData->isEmptySegment = FALSE;	/* we are handling it, reset to avoid future spurious errors */
+                    *err = U_ILLEGAL_ESCAPE_SEQUENCE;
+                    args->converter->toUCallbackReason = UCNV_IRREGULAR;
+                    args->converter->toUBytes[0] = mySourceChar;
+                    args->converter->toULength = 1;
+                    args->target = myTarget;
+                    args->source = mySource;
+                    return;
+                }
                 continue;
 
             case UCNV_SO:
                 if(pToU2022State->cs[1] != 0) {
                     pToU2022State->g=1;
+                    myData->isEmptySegment = TRUE;	/* Begin a new segment, empty so far */
                     continue;
                 } else {
                     /* illegal to have SO before a matching designator */
+                    myData->isEmptySegment = FALSE;	/* Handling a different error, reset this to avoid future spurious errs */
                     break;
                 }
 
             case ESC_2022:
                 mySource--;
 escape:
-                changeState_2022(args->converter,&(mySource), 
-                    mySourceLimit, ISO_2022_CN,err);
+                {
+                    const char * mySourceBefore = mySource;
+                    int8_t toULengthBefore = args->converter->toULength;
+
+                    changeState_2022(args->converter,&(mySource),
+                        mySourceLimit, ISO_2022_CN,err);
+
+                    /* After SO there must be at least one character before a designator (designator error handled separately) */
+                    if(myData->key==0 && U_SUCCESS(*err) && myData->isEmptySegment) {
+                        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
+                        args->converter->toUCallbackReason = UCNV_IRREGULAR;
+                        args->converter->toULength = toULengthBefore + (mySource - mySourceBefore);
+                    }
+                }
 
                 /* invalid or illegal escape sequence */
                 if(U_FAILURE(*err)){
                     args->target = myTarget;
                     args->source = mySource;
+                    myData->isEmptySegment = FALSE;	/* Reset to avoid future spurious errors */
                     return;
                 }
                 continue;
@@ -2779,6 +2842,7 @@
                 /* falls through */
             default:
                 /* convert one or two bytes */
+                myData->isEmptySegment = FALSE;
                 if(pToU2022State->g != 0) {
                     if(mySource < mySourceLimit) {
                         UConverterSharedData *cnv;
diff -Nur -x '*.orig' -x '*~' icu-3.4.1a/build-tree/icu/source/common/ucnv_bld.c icu-3.4.1a.new/build-tree/icu/source/common/ucnv_bld.c
--- icu/source/common/ucnv_bld.c	2005-05-08 03:56:44.000000000 -0400
+++ icu/source/common/ucnv_bld.c	2009-03-25 11:20:04.000000000 -0400
@@ -888,6 +888,7 @@
     myUConverter->subChar1 = myUConverter->sharedData->staticData->subChar1;
     myUConverter->subCharLen = myUConverter->sharedData->staticData->subCharLen;
     uprv_memcpy (myUConverter->subChar, myUConverter->sharedData->staticData->subChar, myUConverter->subCharLen);
+    myUConverter->toUCallbackReason = UCNV_ILLEGAL; /* default reason to invoke (*fromCharErrorBehaviour) */
     myUConverter->preFromUFirstCP = U_SENTINEL;
 
     if(myUConverter != NULL && myUConverter->sharedData->impl->open != NULL) {
diff -Nur -x '*.orig' -x '*~' icu-3.4.1a/build-tree/icu/source/common/ucnv_bld.h icu-3.4.1a.new/build-tree/icu/source/common/ucnv_bld.h
--- icu/source/common/ucnv_bld.h	2005-05-08 03:56:44.000000000 -0400
+++ icu/source/common/ucnv_bld.h	2009-03-25 11:20:57.000000000 -0400
@@ -1,6 +1,6 @@
 /*
 **********************************************************************
-*   Copyright (C) 1999-2005, International Business Machines
+*   Copyright (C) 1999-2006,2008 International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 *
@@ -215,6 +215,9 @@
     char preToU[UCNV_EXT_MAX_BYTES];
     int8_t preFromULength, preToULength;    /* negative: replay */
     int8_t preToUFirstLength;               /* length of first character */
+
+    /* new fields for ICU 4.0 */
+    UConverterCallbackReason toUCallbackReason; /* (*fromCharErrorBehaviour) reason, set when error is detected */
 };
 
 U_CDECL_END /* end of UConverter */
diff -Nur -x '*.orig' -x '*~' icu-3.4.1a/build-tree/icu/source/common/ucnv.c icu-3.4.1a.new/build-tree/icu/source/common/ucnv.c
--- icu/source/common/ucnv.c	2005-05-08 03:56:44.000000000 -0400
+++ icu/source/common/ucnv.c	2009-03-25 11:22:16.000000000 -0400
@@ -1353,11 +1353,14 @@
             cnv->toULength=0;
 
             /* call the callback function */
+            if(cnv->toUCallbackReason==UCNV_ILLEGAL && *err==U_INVALID_CHAR_FOUND) {
+                cnv->toUCallbackReason = UCNV_UNASSIGNED;
+            }
             cnv->fromCharErrorBehaviour(cnv->toUContext, pArgs,
                 cnv->invalidCharBuffer, errorInputLength,
-                (*err==U_INVALID_CHAR_FOUND || *err==U_UNSUPPORTED_ESCAPE_SEQUENCE) ?
-                    UCNV_UNASSIGNED : UCNV_ILLEGAL,
+                cnv->toUCallbackReason,
                 err);
+            cnv->toUCallbackReason = UCNV_ILLEGAL; /* reset to default value */
 
             /*
              * loop back to the offset handling
diff -Nur -x '*.orig' -x '*~' icu-3.4.1a/build-tree/icu/source/common/ucnvhz.c icu-3.4.1a.new/build-tree/icu/source/common/ucnvhz.c
--- icu/source/common/ucnvhz.c	2004-12-01 23:18:34.000000000 -0500
+++ icu/source/common/ucnvhz.c	2009-03-25 11:25:17.000000000 -0400
@@ -59,6 +59,7 @@
     UConverter* gbConverter;
     UBool isStateDBCS;
     UBool isTargetUCharDBCS;
+    UBool isEmptySegment;
 }UConverterDataHZ;
 
 
@@ -103,6 +104,7 @@
         cnv->mode=0;
         if(cnv->extraInfo != NULL){
             ((UConverterDataHZ*)cnv->extraInfo)->isStateDBCS = FALSE;
+            ((UConverterDataHZ*)cnv->extraInfo)->isEmptySegment = FALSE;
         }
     }
     if(choice!=UCNV_RESET_TO_UNICODE) {
@@ -135,6 +137,10 @@
 *   from-GB code '~}' ($7E7D) is outside the defined GB range.)
 *
 *   Source: RFC 1842
+*
+*   Note that the formal syntax in RFC 1842 is invalid. I assume that the
+*   intended definition of single-byte-segment is as follows (pedberg):
+*   single-byte-segment = single-byte-seq 1*single-byte-char
 */
 
 
@@ -167,11 +173,13 @@
                         
                     }
                     *(myTarget++)=(UChar)mySourceChar;
+                    myData->isEmptySegment = FALSE;
                     continue;
             
                 case UCNV_TILDE:
                     if(args->converter->mode ==UCNV_TILDE){
                         *(myTarget++)=(UChar)mySourceChar;
+                        myData->isEmptySegment = FALSE;
                         args->converter->mode=0;
                         continue;
                         
@@ -187,20 +195,22 @@
                 
                 
                 case UCNV_OPEN_BRACE:
-                    if(args->converter->mode == UCNV_TILDE){
-                        args->converter->mode=0;
-                        myData->isStateDBCS = TRUE;
-                        continue;
-                    }
-                    else{
-                        break;
-                    }
-               
-                
                 case UCNV_CLOSE_BRACE:
                     if(args->converter->mode == UCNV_TILDE){
                         args->converter->mode=0;
-                         myData->isStateDBCS = FALSE;
+                        myData->isStateDBCS = (mySourceChar == UCNV_OPEN_BRACE);
+                        if (myData->isEmptySegment) {
+                            myData->isEmptySegment = FALSE; /* we are handling it, reset to avoid future spurious errors */
+                            *err = U_ILLEGAL_ESCAPE_SEQUENCE;
+                            args->converter->toUCallbackReason = UCNV_IRREGULAR;
+                            args->converter->toUBytes[0] = UCNV_TILDE;
+                            args->converter->toUBytes[1] = mySourceChar;
+                            args->converter->toULength = 2;
+                            args->target = myTarget;
+                            args->source = mySource;
+                            return;
+                        }
+                        myData->isEmptySegment = TRUE;
                         continue;
                     }
                     else{
@@ -214,6 +224,7 @@
                     if(args->converter->mode == UCNV_TILDE){
                         args->converter->mode=0;
                         mySourceChar= (UChar)(((UCNV_TILDE+0x80) << 8) | ((mySourceChar & 0x00ff)+0x80));
+			myData->isEmptySegment = FALSE; /* different error here, reset this to avoid spurious future error */
                         goto SAVE_STATE;
                     }
                     
@@ -224,12 +235,14 @@
             if(myData->isStateDBCS){
                 if(args->converter->toUnicodeStatus == 0x00){
                     args->converter->toUnicodeStatus = (UChar) mySourceChar;
+                    myData->isEmptySegment = FALSE;
                     continue;
                 }
                 else{
                     tempBuf[0] = (char) (args->converter->toUnicodeStatus+0x80) ;
                     tempBuf[1] = (char) (mySourceChar+0x80);
                     mySourceChar= (UChar)(((args->converter->toUnicodeStatus+0x80) << 8) | ((mySourceChar & 0x00ff)+0x80));
+                    myData->isEmptySegment = FALSE;
                     args->converter->toUnicodeStatus =0x00;
                     targetUniChar = ucnv_MBCSSimpleGetNextUChar(myData->gbConverter->sharedData,
                         tempBuf, 2, args->converter->useFallback);
@@ -237,10 +250,12 @@
             }
             else{
                 if(args->converter->fromUnicodeStatus == 0x00){
+                    myData->isEmptySegment = FALSE;
                     targetUniChar = ucnv_MBCSSimpleGetNextUChar(myData->gbConverter->sharedData,
                         mySource - 1, 1, args->converter->useFallback);
                 }
                 else{
+                    myData->isEmptySegment = FALSE;
                     goto SAVE_STATE;
                 }
 
diff -Nur -x '*.orig' -x '*~' icu-3.4.1a/build-tree/icu/source/test/cintltst/nucnvtst.c icu-3.4.1a.new/build-tree/icu/source/test/cintltst/nucnvtst.c
--- icu/source/test/cintltst/nucnvtst.c	2004-12-23 16:03:30.000000000 -0500
+++ icu/source/test/cintltst/nucnvtst.c	2009-03-25 11:27:09.000000000 -0400
@@ -77,6 +77,7 @@
 static void TestCoverageMBCS(void);
 static void TestJitterbug2346(void);
 static void TestJitterbug2411(void);
+static void TestJitterbug6175(void);
 void addTestNewConvert(TestNode** root);
 
 /* open a converter, using test data if it begins with '@' */
@@ -262,6 +263,7 @@
    addTest(root, &TestRoundTrippingAllUTF, "tsconv/nucnvtst/TestRoundTrippingAllUTF");
    addTest(root, &TestJitterbug2346, "tsconv/nucnvtst/TestJitterbug2346");
    addTest(root, &TestJitterbug2411, "tsconv/nucnvtst/TestJitterbug2411");
+   addTest(root, &TestJitterbug6175, "tsconv/nucnvtst/TestJitterbug6175");
 
 }
 
@@ -4389,6 +4391,70 @@
     free(offsets);
 }
 
+/* Tests for empty segments in ISO-2022-JP/KR/CN, HZ, check that UConverterCallbackReason is UCNV_IRREGULAR */
+typedef struct {
+    const char *    converterName;
+    const char *    inputText;
+    int             inputTextLength;
+} EmptySegmentTest;
+
+/* Callback for TestJitterbug6175, should only get called for empty segment errors */
+static void UCNV_TO_U_CALLBACK_EMPTYSEGMENT( const void *context, UConverterToUnicodeArgs *toArgs, const char* codeUnits,
+                                             int32_t length, UConverterCallbackReason reason, UErrorCode * err ) {
+    if (reason > UCNV_IRREGULAR) {
+        return;
+    }
+    if (reason != UCNV_IRREGULAR) {
+        log_err("toUnicode callback invoked for empty segment but reason is not UCNV_IRREGULAR\n");
+    }
+    /* Standard stuff below from UCNV_TO_U_CALLBACK_SUBSTITUTE */
+    *err = U_ZERO_ERROR;
+    ucnv_cbToUWriteSub(toArgs,0,err);
+}
+
+enum { kEmptySegmentToUCharsMax = 64 };
+static void TestJitterbug6175(void) {
+    static const char  iso2022jp_a[] = { 0x61, 0x62, 0x1B,0x24,0x42, 0x1B,0x28,0x42, 0x63, 0x64, 0x0D, 0x0A };
+    static const char  iso2022kr_a[] = { 0x1B,0x24,0x29,0x43, 0x61, 0x0E, 0x0F, 0x62, 0x0D, 0x0A };
+    static const char  iso2022cn_a[] = { 0x61, 0x1B,0x24,0x29,0x41, 0x62, 0x0E, 0x0F, 0x1B,0x24,0x2A,0x48, 0x1B,0x4E, 0x6A,0x65, 0x63, 0x0D, 0x0A };
+    static const char  iso2022cn_b[] = { 0x61, 0x1B,0x24,0x29,0x41, 0x62, 0x0E, 0x1B,0x24,0x29,0x47, 0x68,0x64, 0x0F, 0x63, 0x0D, 0x0A };
+    static const char  hzGB2312_a[]  = { 0x61, 0x62, 0x7E,0x7B, 0x7E,0x7D, 0x63, 0x64 };
+    static const EmptySegmentTest emptySegmentTests[] = {
+        /* converterName inputText    inputTextLength */
+        { "ISO-2022-JP", iso2022jp_a, sizeof(iso2022jp_a) },
+        { "ISO-2022-KR", iso2022kr_a, sizeof(iso2022kr_a) },
+        { "ISO-2022-CN", iso2022cn_a, sizeof(iso2022cn_a) },
+        { "ISO-2022-CN", iso2022cn_b, sizeof(iso2022cn_b) },
+        { "HZ-GB-2312",  hzGB2312_a,  sizeof(hzGB2312_a)  },
+        /* terminator: */
+        { NULL,          NULL,        0,                  }
+    };
+    const EmptySegmentTest * testPtr;
+    for (testPtr = emptySegmentTests; testPtr->converterName != NULL; ++testPtr) {
+        UErrorCode   err = U_ZERO_ERROR;
+        UConverter * cnv = ucnv_open(testPtr->converterName, &err);
+        if (U_FAILURE(err)) {
+            log_data_err("Unable to open %s converter: %s\n", testPtr->converterName, u_errorName(err));
+            return;
+        }
+        ucnv_setToUCallBack(cnv, UCNV_TO_U_CALLBACK_EMPTYSEGMENT, NULL, NULL, NULL, &err);
+        if (U_FAILURE(err)) {
+            log_data_err("Unable to setToUCallBack for %s converter: %s\n", testPtr->converterName, u_errorName(err));
+            ucnv_close(cnv);
+            return;
+        }
+        {
+            UChar         toUChars[kEmptySegmentToUCharsMax];
+            UChar *       toUCharsPtr = toUChars;
+            const UChar * toUCharsLimit = toUCharsPtr + kEmptySegmentToUCharsMax;
+            const char *  inCharsPtr = testPtr->inputText;
+            const char *  inCharsLimit = inCharsPtr + testPtr->inputTextLength;
+            ucnv_toUnicode(cnv, &toUCharsPtr, toUCharsLimit, &inCharsPtr, inCharsLimit, NULL, TRUE, &err);
+        }
+        ucnv_close(cnv);
+    }
+}
+
 static void
 TestEBCDIC_STATEFUL() {
     /* test input */
diff -Nur -x '*.orig' -x '*~' icu-3.4.1a/build-tree/icu/source/test/testdata/conversion.txt icu-3.4.1a.new/build-tree/icu/source/test/testdata/conversion.txt
--- icu/source/test/testdata/conversion.txt	2005-06-21 11:14:28.000000000 -0400
+++ icu/source/test/testdata/conversion.txt	2009-03-25 11:29:20.000000000 -0400
@@ -1,6 +1,6 @@
 //*******************************************************************************
 //
-//   Copyright (C) 2003-2005, International Business Machines
+//   Copyright (C) 2003-2008, International Business Machines
 //   Corporation and others.  All Rights Reserved.
 //
 //   file name:  conversion.txt
@@ -177,6 +177,21 @@
           :intvector{ 0, 5, 7, 9, 9, 9, 9, 9, 9, 9, 9, 12 },
           :int{1}, :int{1}, "", "&", :bin{""}
         }
+        // empty segment (using substitution and stop)
+        {
+          "ISO-2022-KR",
+          :bin{ 1b242943610e0f620d0a },
+          "a\uFFFDb\u000D\u000A",
+          :intvector{ 4, 6, 7, 8, 9 },
+          :int{1}, :int{1}, "", "?", :bin{""}
+        }
+        {
+          "ISO-2022-KR",
+          :bin{ 1b242943610e0f620d0a },
+          "a",
+          :intvector{ 4 },
+          :int{1}, :int{1}, "illesc", ".", :bin{"0f"}
+        }
 
         // ISO-2022-JP
 
@@ -227,6 +242,21 @@
           :bin{ 41c15c1b284a5cc242 }, "A\uff81\\\xa5\uff82B", :intvector{ 0, 1, 2, 6, 7, 8 },
           :int{1}, :int{1}, "", ".", :bin{""}
         }
+        // empty segment (using substitution and stop)
+        {
+          "ISO-2022-JP",
+          :bin{ 61621b24421b284263640d0a },
+          "ab\uFFFDcd\u000D\u000A",
+          :intvector{ 0, 1, 5, 8, 9, 10, 11 },
+          :int{1}, :int{1}, "", "?", :bin{""}
+        }
+        {
+          "ISO-2022-JP",
+          :bin{ 61621b24421b284263640d0a },
+          "ab",
+          :intvector{ 0, 1 },
+          :int{1}, :int{1}, "illesc", ".", :bin{"1b2842"}
+        }
 
         // ISO-2022-CN
 
@@ -297,6 +327,36 @@
           :bin{ 411b242b491b4f2121 }, "\x41", :intvector{ 0 },
           :int{1}, :int{1}, "unsuppesc", ".", :bin{ 1b242b49 }
         }
+        // empty segment 1 (using substitution and stop)
+        {
+          "ISO-2022-CN",
+          :bin{ 611b242941620e0f1b242a481b4e6a65630d0a },
+          "ab\uFFFD\u994Cc\u000D\u000A",
+          :intvector{ 0, 5, 7, 14, 16, 17, 18 },
+          :int{1}, :int{1}, "", "?", :bin{""}
+        }
+        {
+          "ISO-2022-CN",
+          :bin{ 611b242941620e0f1b242a481b4e6a65630d0a },
+          "ab",
+          :intvector{ 0, 5 },
+          :int{1}, :int{1}, "illesc", ".", :bin{"0f"}
+        }
+        // empty segment 2 (using substitution and stop)
+        {
+          "ISO-2022-CN",
+          :bin{ 611b242941620e1b24294768640f630d0a },
+          "ab\uFFFD\u5F70c\u000D\u000A",
+          :intvector{ 0, 5, 7, 11, 14, 15, 16 },
+          :int{1}, :int{1}, "", "?", :bin{""}
+        }
+        {
+          "ISO-2022-CN",
+          :bin{ 611b242941620e1b24294768640f630d0a },
+          "ab",
+          :intvector{ 0, 5 },
+          :int{1}, :int{1}, "illesc", ".", :bin{"1b242947"}
+        }
 
         // ISO-2022 SBCS
         // [U_ENABLE_GENERIC_ISO_2022]
@@ -311,6 +371,39 @@
         //  :int{1}, :int{1}, "", ".", :bin{""}
         //}
 
+        // HZ-GB-2312
+
+        // empty segment 1 (using substitution and stop)
+        {
+          "HZ-GB-2312",
+          :bin{ 61627e7b7e7d6364 },
+          "ab\uFFFDcd",
+          :intvector{ 0, 1, 4, 6, 7 },
+          :int{1}, :int{1}, "", "?", :bin{""}
+        }
+        {
+          "HZ-GB-2312",
+          :bin{ 61627e7b7e7d63640d0a },
+          "ab",
+          :intvector{ 0, 1 },
+          :int{1}, :int{1}, "illesc", ".", :bin{"7e7d"}
+        }
+        // empty segment 2 & legal redundant switches (using substitution and stop)
+        {
+          "HZ-GB-2312",
+          :bin{ 61627e7b323b3f557e7b7e7b523b7e7d63647e7d65667e7d7e7d },
+          "ab\u4E0D\u7A7A\uFFFD\u4E00cdef\uFFFD",
+          :intvector{ 0, 1, 4, 6, 10, 12, 16, 17, 20, 21, 24 },
+          :int{1}, :int{1}, "", "?", :bin{""}
+        }
+        {
+          "HZ-GB-2312",
+          :bin{ 61627e7b323b3f557e7b7e7b523b7e7d63647e7d65667e7d7e7d },
+          "ab\u4E0D\u7A7A",
+          :intvector{ 0, 1, 4, 6 },
+          :int{1}, :int{1}, "illesc", ".", :bin{"7e7b"}
+        }
+
         // DBCS-only extensions
         {
           "ibm-970",
